import React, { useEffect, useRef, useState } from 'react';
import mapboxgl from 'mapbox-gl';
import * as turf from '@turf/turf';
import { getMarine } from './lib/openmeteo';
import { insidePolygon } from './lib/geoutils';

mapboxgl.accessToken = import.meta.env.VITE_MAPBOX_TOKEN;

const centerDefault = [85, 12];

const MAP_STYLES = {
  standard: 'mapbox://styles/mapbox/streets-v12',
  satellite: 'mapbox://styles/mapbox/satellite-v9',
  infrared: 'mapbox://styles/mapbox/dark-v11',
};

const fishData = [
  { name: 'Indian Mackerel', coords: [85, 12], info: 'Common near Bay of Bengal.' },
  { name: 'Hilsa', coords: [84, 13], info: 'Migrates during monsoon near coastal waters.' },
  { name: 'Pomfret', coords: [86, 14], info: 'High density near Lakshadweep waters.' },
];

// Get fish species closest to given coords within 100 km range
function getClosestFishSpecies(lon, lat) {
  const pt = turf.point([lon, lat]);
  let minDist = Infinity;
  let closest = null;
  for (const fish of fishData) {
    const dist = turf.distance(pt, turf.point(fish.coords), { units: 'kilometers' });
    if (dist < 100 && dist < minDist) {
      minDist = dist;
      closest = { ...fish, distance: dist.toFixed(2) };
    }
  }
  return closest;
}

export default function App() {
  const mapRef = useRef(null);
  const map = useRef(null);
  const [pos, setPos] = useState({ lat: centerDefault[1], lon: centerDefault[0] });
  const sidebarRef = useRef(null);
  const [sidebarPos, setSidebarPos] = useState({ x: 12, y: 12 });
  const dragState = useRef({ dragging: false, startX: 0, startY: 0, origX: 12, origY: 12 });
  const [marineData, setMarineData] = useState(null);
  const [safety, setSafety] = useState({ label: 'Loading location...', cls: 'warn' });
  const [mapStyle, setMapStyle] = useState('standard');
  const [alertMsg, setAlertMsg] = useState(null);
  const [fishInfo, setFishInfo] = useState(null);
  const [distToCoast, setDistToCoast] = useState(null);

  useEffect(() => {
    if (map.current) return;

    map.current = new mapboxgl.Map({
      container: mapRef.current,
      style: MAP_STYLES.standard,
      center: centerDefault,
      zoom: 6,
      pitch: 40,
      bearing: -10,
    });

    const addLayers = () => {
      map.current.addSource('eez', { type: 'geojson', data: '/data/eez_india.geojson' });
      map.current.addLayer({
        id: 'eez-fill',
        type: 'fill',
        source: 'eez',
        paint: { 'fill-color': '#00FFC8', 'fill-opacity': 0.1 },
      });
      map.current.addLayer({
        id: 'eez-line',
        type: 'line',
        source: 'eez',
        paint: { 'line-color': '#00FFC8', 'line-width': 3 },
      });
      map.current.addSource('pfz', { type: 'geojson', data: '/data/pfz_sample.geojson' });
      map.current.addLayer({
        id: 'pfz-heat',
        type: 'heatmap',
        source: 'pfz',
        maxzoom: 9,
        paint: {
          'heatmap-intensity': 1.5,
          'heatmap-radius': 20,
          'heatmap-color': [
            'interpolate',
            ['linear'],
            ['heatmap-density'],
            0, 'rgba(0,0,0,0)',
            0.2, '#0077ff',
            0.4, '#00ffc8',
            0.6, '#88ff00',
            0.8, '#ffec00',
            1, '#ff0033',
          ],
        },
      });
      map.current.addSource('boat', { type: 'geojson', data: turf.point([pos.lon, pos.lat]) });
      map.current.addLayer({
        id: 'boat',
        type: 'circle',
        source: 'boat',
        paint: {
          'circle-radius': 11,
          'circle-color': '#FFD400',
          'circle-stroke-width': 3,
          'circle-stroke-color': '#3c4a58',
        },
      });
    };

    map.current.on('load', () => {
      addLayers();

      // Follow mouse cursor to move boat and update info
      map.current.on('mousemove', (e) => {
        updatePosition(e.lngLat.lng, e.lngLat.lat);
      });

      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition((p) => {
          updatePosition(p.coords.longitude, p.coords.latitude);
          map.current.flyTo({ center: [p.coords.longitude, p.coords.latitude], zoom: 8, speed: 0.6 });
        }, () => {
          // Permission denied fallback: start center
          updatePosition(centerDefault[0], centerDefault[1]);
        });
      } else {
        updatePosition(centerDefault[0], centerDefault[1]);
      }
    });

    map.current.on('style.load', () => {
      addLayers();
      if (map.current.getSource('boat')) {
        map.current.getSource('boat').setData(turf.point([pos.lon, pos.lat]));
      }
    });
  }, []);

  function updatePosition(lon, lat) {
    setPos({ lon, lat });
    if (!map.current) return;
    const boatSource = map.current.getSource('boat');
    boatSource.setData(turf.point([lon, lat]));
    refreshMarineData(lat, lon);
    updateSafety(lon, lat);
    updateFishInfoAndDistance(lon, lat);
  }

  async function refreshMarineData(lat, lon) {
    const marine = await getMarine(lat, lon);
    setMarineData(marine);
  }

  function updateSafety(lon, lat) {
    if (!map.current) return;

  const eezSrc = map.current.getSource('eez');
  if (!eezSrc || !eezSrc._data || !eezSrc._data.features?.length) {
    setSafety({ label: 'EEZ data not loaded', cls: 'warn' });
    return;
  }

  const pt = turf.point([lon, lat]);
  const eezFeature = eezSrc._data.features[0];

  const inside = insidePolygon(pt, eezFeature);
  let label = 'Inside Indian EEZ (Safe)';
  let cls = 'safe';

  if (!inside) {
    label = 'Outside Indian EEZ! Alert Coast Guard';
    cls = 'danger';
    if (map.current.getLayer('boat')) {
      map.current.setPaintProperty('boat', 'circle-color', '#FF0000');
    }
    setAlertMsg(label);
  } else {
    if (map.current.getLayer('boat')) {
      map.current.setPaintProperty('boat', 'circle-color', '#FFD400');
    }
    setAlertMsg(null);
  }

  setSafety({ label, cls });
  }

  function updateFishInfoAndDistance(lon, lat) {
    const fish = getClosestFishSpecies(lon, lat);
    setFishInfo(fish);
  
  function onDragStart(e) {
  const isTouch = e.type === 'touchstart';
  const clientX = isTouch ? e.touches[0].clientX : e.clientX;
  const clientY = isTouch ? e.touches[0].clientY : e.clientY;
  dragState.current.dragging = true;
  dragState.current.startX = clientX;
  dragState.current.startY = clientY;
  dragState.current.origX = sidebarPos.x;
  dragState.current.origY = sidebarPos.y;
  document.body.style.userSelect = 'none';
}

function onDragMove(e) {
  if (!dragState.current.dragging) return;
  const isTouch = e.type === 'touchmove';
  const clientX = isTouch ? e.touches[0].clientX : e.clientX;
  const clientY = isTouch ? e.touches[0].clientY : e.clientY;

  const dx = clientX - dragState.current.startX;
  const dy = clientY - dragState.current.startY;

  const vw = window.innerWidth;
  const vh = window.innerHeight;
  const panel = sidebarRef.current;
  const w = panel ? panel.offsetWidth : 320;
  const h = panel ? panel.offsetHeight : 480;

  const nextX = Math.min(Math.max(0, dragState.current.origX + dx), vw - w);
  const nextY = Math.min(Math.max(0, dragState.current.origY + dy), vh - h);

  setSidebarPos({ x: nextX, y: nextY });
}

function onDragEnd() {
  dragState.current.dragging = false;
  document.body.style.userSelect = '';
}

useEffect(() => {
  const move = (e) => onDragMove(e);
  const up = () => onDragEnd();
  window.addEventListener('mousemove', move);
  window.addEventListener('mouseup', up);
  window.addEventListener('touchmove', move, { passive: false });
  window.addEventListener('touchend', up);
  return () => {
    window.removeEventListener('mousemove', move);
    window.removeEventListener('mouseup', up);
    window.removeEventListener('touchmove', move);
    window.removeEventListener('touchend', up);
  };
}, []);
function onDragStart(e) {
  const isTouch = e.type === 'touchstart';
  const clientX = isTouch ? e.touches[0].clientX : e.clientX;
  const clientY = isTouch ? e.touches[0].clientY : e.clientY;
  dragState.current.dragging = true;
  dragState.current.startX = clientX;
  dragState.current.startY = clientY;
  dragState.current.origX = sidebarPos.x;
  dragState.current.origY = sidebarPos.y;
  document.body.style.userSelect = 'none';
}

function onDragMove(e) {
  if (!dragState.current.dragging) return;
  const isTouch = e.type === 'touchmove';
  const clientX = isTouch ? e.touches[0].clientX : e.clientX;
  const clientY = isTouch ? e.touches[0].clientY : e.clientY;

  const dx = clientX - dragState.current.startX;
  const dy = clientY - dragState.current.startY;

  const vw = window.innerWidth;
  const vh = window.innerHeight;
  const panel = sidebarRef.current;
  const w = panel ? panel.offsetWidth : 320;
  const h = panel ? panel.offsetHeight : 480;

  const nextX = Math.min(Math.max(0, dragState.current.origX + dx), vw - w);
  const nextY = Math.min(Math.max(0, dragState.current.origY + dy), vh - h);

  setSidebarPos({ x: nextX, y: nextY });
}

function onDragEnd() {
  dragState.current.dragging = false;
  document.body.style.userSelect = '';
}

useEffect(() => {
  const move = (e) => onDragMove(e);
  const up = () => onDragEnd();
  window.addEventListener('mousemove', move);
  window.addEventListener('mouseup', up);
  window.addEventListener('touchmove', move, { passive: false });
  window.addEventListener('touchend', up);
  return () => {
    window.removeEventListener('mousemove', move);
    window.removeEventListener('mouseup', up);
    window.removeEventListener('touchmove', move);
    window.removeEventListener('touchend', up);
  };
}, []);


    if (map.current) {
      const pt = turf.point([lon, lat]);
      const eez = map.current.getSource('eez')._data;
      const distKm = turf.pointToLineDistance(pt, eez.features[0], { units: 'kilometers' });
      setDistToCoast(distKm.toFixed(2));
    }
  }

  function onMapStyleChange(e) {
    const styleKey = e.target.value;
    setMapStyle(styleKey);
    if (map.current) {
      map.current.setStyle(MAP_STYLES[styleKey]);
    }
  }

  return (
    <div className="app" style={{ display: 'flex', height: '100vh' }}>
      <div ref={mapRef} className="map" style={{ flex: 1, height: '100vh' }} />

      <div className="sidebar" style={{
        
        width: '320px',
        padding: '16px',
        background: 'rgba(20,20,30,0.9)',
        color: 'white',
        overflowY: 'auto',
        fontFamily: 'Inter, system-ui',
        boxShadow: '-2px 0 13px rgba(0,255,200,0.3)'
      }}>
        <h1>NAAV SAATHI</h1>

        <div className={`status ${safety.cls}`}>{safety.label}</div>

        {alertMsg && (
          <div className="status danger" style={{ marginTop: '8px', fontWeight: 'bold' }}>
            {alertMsg}
          </div>
        )}

        <div className="input-group">
          <label htmlFor="latInput">Latitude</label>
          <input
            id="latInput"
            type="number"
            step="0.0001"
            value={pos.lat}
            onChange={(e) => {
              const newLat = parseFloat(e.target.value);
              if (!isNaN(newLat)) updatePosition(pos.lon, newLat);
            }}
          />
        </div>

        <div className="input-group">
          <label htmlFor="lonInput">Longitude</label>
          <input
            id="lonInput"
            type="number"
            step="0.0001"
            value={pos.lon}
            onChange={(e) => {
              const newLon = parseFloat(e.target.value);
              if (!isNaN(newLon)) updatePosition(newLon, pos.lat);
            }}
          />
        </div>

        <div className="row" style={{ marginTop: '12px' }}>
          <div className="card">
            <div className="badge">Waves (m)</div>
            <div className="value">{marineData?.hourly?.wave_height?.[0]?.toFixed(2) || '—'}</div>
          </div>

          <div className="card">
            <div className="badge">Water Temp (°C)</div>
            <div className="value">{marineData?.hourly?.sea_surface_temperature?.[0]?.toFixed(2) || '—'}</div>
          </div>

          <div className="card">
            <div className="badge">Tide Height (m)</div>
            <div className="value">{marineData?.hourly?.tide_height?.[0]?.toFixed(2) || '—'}</div>
          </div>

          <div className="card">
            <div className="badge">Wind Speed (km/h)</div>
            <div className="value">{marineData?.hourly?.wind_speed_10m?.[0]?.toFixed(2) || '—'}</div>
          </div>
        </div>

        <div style={{ marginTop: '20px' }}>
          <h3>Fish Species Nearby:</h3>
          {fishInfo ? (
            <div>
              <strong>{fishInfo.name}</strong>
              <p>{fishInfo.info}</p>
              <p>Approximate Distance: {fishInfo.distance} km</p>
            </div>
          ) : (
            <p>No fish data nearby.</p>
          )}

          <h3>Distance to Indian EEZ boundary:</h3>
          <p>{distToCoast ? `${distToCoast} km` : 'Calculating...'}</p>
        </div>

        <div className="toolbar" style={{ marginTop: '16px' }}>
          <select value={mapStyle} onChange={onMapStyleChange} style={{ width: '100%' }}>
            <option value="standard">Standard Map</option>
            <option value="satellite">Satellite Map</option>
            <option value="infrared">Infrared Map</option>
          </select>

          <button
            className="btn"
            style={{ marginTop: '8px', width: '100%' }}
            onClick={() => {
              if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition((p) => {
                  updatePosition(p.coords.longitude, p.coords.latitude);
                  map.current.flyTo({ center: [p.coords.longitude, p.coords.latitude], zoom: 8, speed: 0.6 });
                });
              }
            }}
          >
            Use My Location
          </button>

          <button
            className="btn"
            style={{ marginTop: '8px', width: '100%' }}
            onClick={() => {
              updatePosition(centerDefault[0], centerDefault[1]);
              map.current.flyTo({ center: centerDefault, zoom: 5 });
            }}
          >
            Reset View
          </button>

          <button
            className="btn"
            style={{ marginTop: '16px', width: '100%' }}
            onClick={() => updatePosition(70, 10)}
          >
            Simulate Outside Boundary
          </button>
        </div>

      </div>
    </div>
  );
}
